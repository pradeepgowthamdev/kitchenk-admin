import fs from "fs";
import path from "path";
import PDFDocument from "pdfkit";
import { v4 as uuidv4 } from "uuid";

const ensureDir = (dirPath) => {
  if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true });
};

export const generateInventoryPdf = async (req, res) => {
  try {
    const { items = [], note = "" } = req.body;

    if (!Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ success: false, message: "items required" });
    }

    const dir = path.join(process.cwd(), "temp-pdfs");
    ensureDir(dir);

    const file = `inventory-${uuidv4()}.pdf`;
    const filePath = path.join(dir, file);

    const doc = new PDFDocument({ size: "A4", margin: 40 });
    const out = fs.createWriteStream(filePath);
    doc.pipe(out);

    // Header
    doc.fontSize(18).text("KitchenK Store-room Inventory", { align: "center" });
    doc.moveDown(0.8);

    if (String(note || "").trim()) {
      doc.fontSize(12).text(`Note: ${String(note).trim()}`);
      doc.moveDown(0.8);
    }

    // Table-ish layout
    doc.fontSize(11);
    let i = 1;

    for (const it of items) {
      const name = String(it?.name || "").trim();
      const brand = String(it?.selectedBrand || it?.brand || "").trim();
      const qty = String(it?.qtyNumber || it?.qty || "").trim();
      const unit = String(it?.unit || "").trim();

      const line = `${i}. ${name}${brand ? ` | ${brand}` : ""}${qty ? ` | ${qty}${unit ? ` ${unit}` : ""}` : ""}`;
      doc.text(line);
      i++;
    }

    doc.moveDown(1.2);
    doc.fontSize(10).fillColor("#6b7280").text("Generated by KitchenK Admin");
    doc.end();

    out.on("finish", () => {
      // ✅ IMPORTANT: return relative download URL (frontend will prefix API_URL)
      return res.json({
        success: true,
        downloadUrl: `/api/reports/download/${file}`,
      });
    });

    out.on("error", (e) => {
      console.error("PDF write error:", e);
      return res.status(500).json({ success: false, message: "PDF write failed" });
    });
  } catch (err) {
    console.error("PDF generation error:", err);
    return res.status(500).json({ success: false, message: "PDF generation failed" });
  }
};

// ✅ Download once + auto delete after response ends
export const downloadAndDeletePdf = (req, res) => {
  try {
    const file = req.params.file || "";
    if (!file.endsWith(".pdf")) return res.status(400).send("Invalid file");

    const filePath = path.join(process.cwd(), "temp-pdfs", file);

    if (!fs.existsSync(filePath)) {
      return res.status(404).send("File expired or not found");
    }

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="${file}"`);

    const stream = fs.createReadStream(filePath);

    stream.on("error", (e) => {
      console.error("Read stream error:", e);
      return res.status(500).send("Unable to read file");
    });

    // When download finished/connection closed → delete file
    res.on("finish", () => {
      fs.unlink(filePath, (e) => e && console.error("Delete failed:", e.message));
    });
    res.on("close", () => {
      fs.unlink(filePath, (e) => e && console.error("Delete failed:", e.message));
    });

    stream.pipe(res);
  } catch (err) {
    console.error("download error:", err);
    return res.status(500).send("Server error");
  }
};