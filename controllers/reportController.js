// controllers/reportController.js
import fs from "fs";
import path from "path";
import PDFDocument from "pdfkit";
import { v4 as uuidv4 } from "uuid";

const ensureDir = (dirPath) => {
  if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true });
};

const safeText = (v) => String(v ?? "").trim();

const getBaseUrl = (req) => {
  // If you set PUBLIC_API_BASE=https://api.gogrocer.ca in AWS .env, it will use that.
  // Otherwise it falls back to request host.
  const envBase = safeText(process.env.PUBLIC_API_BASE).replace(/\/+$/, "");
  if (envBase) return envBase;

  const proto =
    req.headers["x-forwarded-proto"] ||
    (req.secure ? "https" : "http");

  const host =
    req.headers["x-forwarded-host"] ||
    req.headers.host;

  return `${proto}://${host}`;
};

export const generateInventoryPdf = async (req, res) => {
  try {
    const { items = [], note = "" } = req.body;

    if (!Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ success: false, message: "items required" });
    }

    const dir = path.join(process.cwd(), "temp-pdfs");
    ensureDir(dir);

    const file = `inventory-${uuidv4()}.pdf`;
    const filePath = path.join(dir, file);

    const doc = new PDFDocument({ size: "A4", margin: 40 });
    const out = fs.createWriteStream(filePath);

    doc.pipe(out);

    // Header
    doc.fontSize(18).text("KitchenK Store-room Inventory", { align: "center" });
    doc.moveDown(0.8);

    const noteText = safeText(note);
    if (noteText) {
      doc.fontSize(12).fillColor("#111827").text(`Note: ${noteText}`);
      doc.moveDown(0.8);
    }

    // Lines
    doc.fontSize(11).fillColor("#111827");
    let i = 1;

    for (const it of items) {
      const name = safeText(it?.name);
      const brand = safeText(it?.selectedBrand || it?.brand);
      const qty = safeText(it?.qtyNumber || it?.qty);
      const unit = safeText(it?.unit);

      const line = `${i}. ${name || "-"}` +
        (brand ? ` | ${brand}` : "") +
        (qty ? ` | ${qty}${unit ? ` ${unit}` : ""}` : "");

      doc.text(line);
      i++;
    }

    doc.moveDown(1.2);
    doc.fontSize(10).fillColor("#6b7280").text("Generated by KitchenK Admin");
    doc.end();

    out.on("finish", () => {
      const baseUrl = getBaseUrl(req);
      const downloadPath = `/api/reports/download/${file}`;

      return res.json({
        success: true,
        // ✅ Always a full URL
        downloadUrl: `${baseUrl}${downloadPath}`,
        // optional extra fields
        file,
        expires: "one-time",
      });
    });

    out.on("error", (e) => {
      console.error("PDF write error:", e);
      return res.status(500).json({ success: false, message: "PDF write failed" });
    });
  } catch (err) {
    console.error("PDF generation error:", err);
    return res.status(500).json({ success: false, message: "PDF generation failed" });
  }
};

// ✅ Download once + auto delete after response ends (delete only once)
export const downloadAndDeletePdf = (req, res) => {
  try {
    const file = safeText(req.params.file);

    // basic safety
    if (!file || !file.endsWith(".pdf") || file.includes("..") || file.includes("/")) {
      return res.status(400).send("Invalid file");
    }

    const filePath = path.join(process.cwd(), "temp-pdfs", file);

    if (!fs.existsSync(filePath)) {
      return res.status(404).send("File expired or not found");
    }

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="${file}"`);

    const stream = fs.createReadStream(filePath);

    stream.on("error", (e) => {
      console.error("Read stream error:", e);
      return res.status(500).send("Unable to read file");
    });

    let deleted = false;
    const deleteOnce = () => {
      if (deleted) return;
      deleted = true;
      fs.unlink(filePath, (e) => e && console.error("Delete failed:", e.message));
    };

    // When response is done or connection closed -> delete file
    res.on("finish", deleteOnce);
    res.on("close", deleteOnce);

    stream.pipe(res);
  } catch (err) {
    console.error("download error:", err);
    return res.status(500).send("Server error");
  }
};